import copy
import dataclasses
from abc import ABC
from enum import Enum

import game
from game.cache import cached, from_cache
from game.structures.enums import InputType
from game.structures.loadable import LoadableMixin
from game.structures.loadable_factory import LoadableFactory
from game.structures.messages import ComponentFactory, StringContent
from game.structures.state_device import FiniteStateDevice
from game.systems.event import Event
from game.systems.requirement.requirements import RequirementsMixin

from loguru import logger


@dataclasses.dataclass
class DialogNodeBase(ABC):
    node_id: int  # Unique ID for the node. Every node must be unique, even when considered between dialogs.
    options: dict[str, int]  # A map of selectable "options" to their corresponding target nodes. -1 means end dialog.
    text: str
    visited: bool = False
    allow_multiple_visits: bool = True
    multiple_event_triggers: bool = False  # If False, events will only trigger when visited==False
    persistent: bool = False  # If True, properties will be persisted in storage between sessions
    on_enter: list[Event] = dataclasses.field(default_factory=list)  # Events triggered when node is entered.

    def get_option_text(self) -> list[str]:
        """Return a list containing all the strings for each option in the node"""
        return [s for s in self.options.keys()]

    def should_trigger_events(self) -> bool:
        """
        Determine if events should be triggered.
        """

        return self.multiple_event_triggers or not self.visited

    def get_events(self) -> list[Event]:
        """Return a deep copy of each on_enter Event object"""
        return [copy.deepcopy(e) for e in self.on_enter]

    def trigger_events(self) -> None:
        """
        Run a deep copy of each event
        """

        for event in self.get_events():
            game.state_device_controller.add_state_device(event)


class DialogNode(RequirementsMixin, LoadableMixin, DialogNodeBase):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        if self.persistent:
            # Handle fetching properties from storage
            pass

    @staticmethod
    @cached([LoadableMixin.LOADER_KEY, "DialogNode", LoadableMixin.ATTR_KEY])
    def from_json(json: dict[str, any]) -> any:
        """
        Loads a ResourceEvent object from a JSON blob.

        Required JSON fields:
        - node_id: int
        - options: dict[str, dict[str, any]]
        - text: str

        Optional JSON fields:
        - visited: bool
        - allow_multiple_visits: bool
        - multiple_event_triggers: bool
        - persistent: bool
        - on_enter: list[Event]
        """

        required_fields = [
            ("node_id", int),
            ("options", dict),
            ("text", str)
        ]

        optional_fields = [
            ("visited", bool),
            ("allow_multiple_visits", bool),
            ("multiple_event_triggers", bool),
            ("persistent", bool)
        ]

        LoadableFactory.validate_fields(required_fields, json)
        LoadableFactory.validate_fields(optional_fields, json, False, False)

        if json["class"] != "ResourceEvent":
            raise ValueError()

        kwargs = LoadableFactory.collect_optional_fields(optional_fields, json)

        if "on_enter" in kwargs:
            actual_events = []
            for raw_event in kwargs["on_enter"]:
                try:
                    actual_events.append(LoadableFactory.get(raw_event))
                except (ValueError, TypeError) as e:
                    logger.error(f"Caught an error generated by a loader while attempting to load a DialogNode with id"
                                 f" {json['node_id']}!")
                    raise e

        return DialogNode(**kwargs)


class DialogBase(ABC):
    """Base Class for Dialog objects. Implements all non-interface functionality of Dialog"""

    def __init__(self, dialog_id: int, nodes: list[DialogNode], initial_node_id: int = 0):
        if len(nodes) < 1:
            raise ValueError("Unable to instantiate Dialog Object with zero nodes!")
        self.id = dialog_id
        self.nodes: dict[int, DialogNode] = {n.node_id: n for n in nodes}
        self.initial_node_id: int = initial_node_id
        self._current_node: int = initial_node_id

        if initial_node_id not in self.nodes:
            raise ValueError(f"Invalid starting node id {initial_node_id} for Dialog with id {self.id}")

        def get() -> DialogNode:
            return self.nodes[self._current_node] if self._current_node > 0 else None


class Dialog(LoadableMixin, DialogBase):
    """A class that implements a logic back-end and datastructure for NPC dialog. Intended to be embedded within
    FiniteStateDevice objects."""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    @staticmethod
    @cached([LoadableMixin.LOADER_KEY, "Dialog", LoadableMixin.ATTR_KEY])
    def from_json(json: dict[str, any]) -> any:
        pass


class DialogEvent(Event):
    """An Event that hosts the Dialog objects logic and manages spawning TextEvents for it."""

    class States(Enum):
        DEFAULT = 0
        VISIT_NODE = 1
        TERMINATE = -1

    def __init__(self, dialog_id: int, **kwargs):
        super().__init__(**kwargs)

        self.current_node: DialogNode = None
        self.dialog: Dialog = None

        @FiniteStateDevice.state_logic(self, self.States.DEFAULT, InputType.SILENT)
        def logic(_: any) -> None:
            self.dialog = copy.deepcopy(from_cache("managers.DialogManager").get_dialog(dialog_id))

        @FiniteStateDevice.state_logic(self, self.States.VISIT_NODE, InputType.INT,
                                       input_min=0, input_max=len(self.current_node.get_option_text()) - 1)
        def logic(user_input: int):
            user_choice: str = self.current_node.get_option_text()[user_input]
            next_node: int = self.current_node.options[user_choice]
            if next_node is None:
                self.set_state(self.States.TERMINATE)
                return

            self.current_node = self.dialog.nodes[next_node]

        @FiniteStateDevice.state_content(self, self.States.VISIT_NODE)
        def content() -> dict:
            return ComponentFactory.get(
                [self.current_node.text],
                self.current_node.get_option_text()
            )

    @staticmethod
    @cached([LoadableMixin.LOADER_KEY, "DialogEvent", LoadableMixin.ATTR_KEY])
    def from_json(json: dict[str, any]) -> any:
        pass
