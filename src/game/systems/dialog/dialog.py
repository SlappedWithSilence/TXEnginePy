import copy
import dataclasses
from abc import ABC
from enum import Enum

import game
from game.cache import cached, from_cache
from game.structures.enums import InputType
from game.structures.loadable import LoadableMixin
from game.structures.loadable_factory import LoadableFactory
from game.structures.state_device import FiniteStateDevice
from game.systems.event import Event
from game.systems.requirement.requirements import RequirementsMixin

from loguru import logger


@dataclasses.dataclass
class DialogNodeBase(ABC):
    node_id: int  # Unique ID for the node. Every node must be unique, even when considered between dialogs.
    options: dict[str, int]  # A map of selectable "options" to their corresponding target nodes. -1 means end dialog.
    text: str
    visited: bool = False
    allow_multiple_visits: bool = True
    multiple_event_triggers: bool = False  # If False, events will only trigger when visited==False
    persistent: bool = False  # If True, properties will be persisted in storage between sessions
    on_enter: list[Event] = dataclasses.field(default_factory=list)  # Events triggered when node is entered.

    def get_option_text(self) -> list[str]:
        return [s for s in self.options.keys()]

    def get_next_node(self, option: str) -> int | None:
        """
        Get the next node to transition to after the current node is completed. If the target node id is -1, return None
        """
        if option not in self.options.keys():
            raise ValueError(f"No such option: {option}")

        if "next node" not in self.options[option]:
            raise KeyError(f"Unable to find required key `next_node` for option {option}")

        return self.options[option] if self.options[option] > 0 else None

    def should_trigger_events(self) -> bool:
        """
        Determine if events should be triggered.
        """

        return self.multiple_event_triggers or not self.visited

    def get_events(self) -> list[Event]:
        return [copy.deepcopy(e) for e in self.on_enter]

    def trigger_events(self) -> None:
        """
        Run a deep copy of each event
        """

        for event in self.get_events():
            game.state_device_controller.add_state_device(event)


class DialogNode(RequirementsMixin, LoadableMixin, DialogNodeBase):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        if self.persistent:
            # Handle fetching properties from storage
            pass

    @staticmethod
    @cached([LoadableMixin.LOADER_KEY, "DialogNode", LoadableMixin.ATTR_KEY])
    def from_json(json: dict[str, any]) -> any:
        """
        Loads a ResourceEvent object from a JSON blob.

        Required JSON fields:
        - node_id: int
        - options: dict[str, dict[str, any]]
        - text: str

        Optional JSON fields:
        - visited: bool
        - allow_multiple_visits: bool
        - multiple_event_triggers: bool
        - persistent: bool
        - on_enter: list[Event]
        """

        required_fields = [
            ("node_id", int),
            ("options", dict),
            ("text", str)
        ]

        optional_fields = [
            ("visited", bool),
            ("allow_multiple_visits", bool),
            ("multiple_event_triggers", bool),
            ("persistent", bool)
        ]

        LoadableFactory.validate_fields(required_fields, json)
        LoadableFactory.validate_fields(optional_fields, json, False, False)

        if json["class"] != "ResourceEvent":
            raise ValueError()

        kwargs = LoadableFactory.collect_optional_fields(optional_fields, json)

        if "on_enter" in kwargs:
            actual_events = []
            for raw_event in kwargs["on_enter"]:
                try:
                    actual_events.append(LoadableFactory.get(raw_event))
                except (ValueError, TypeError) as e:
                    logger.error(f"Caught an error generated by a loader while attempting to load a DialogNode with id"
                                 f" {json['node_id']}!")
                    raise e

        return DialogNode(**kwargs)


class DialogBase(ABC):
    """Base Class for Dialog objects. Implements all non-interface functionality of Dialog"""

    def __init__(self, dialog_id: int, nodes: list[DialogNode], initial_node_id: int = 0):
        if len(nodes) < 1:
            raise ValueError("Unable to instantiate Dialog Object with zero nodes!")
        self.id = dialog_id
        self.nodes: list[DialogNode] = nodes
        self.initial_node_id: int = initial_node_id


class Dialog(LoadableMixin, DialogBase):
    """A class that implements a logic back-end and datastructure for NPC dialog. Intended to be embedded within
    FiniteStateDevice objects."""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    @staticmethod
    @cached([LoadableMixin.LOADER_KEY, "Dialog", LoadableMixin.ATTR_KEY])
    def from_json(json: dict[str, any]) -> any:
        pass

    def visit(self, node_id: int) -> DialogNode:
        """Marks a node as visited, conditionally launches any on_enter Events, and then returns the Node object"""


class DialogEvent(Event):
    """An Event that hosts the Dialog objects logic and manages spawning TextEvents for it."""

    class States(Enum):
        DEFAULT = 0
        TERMINATE = -1

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        @FiniteStateDevice.state_logic(self, self.States.DEFAULT, InputType.SILENT)
        def logic(_: any) -> None:
            pass

    @staticmethod
    @cached([LoadableMixin.LOADER_KEY, "DialogEvent", LoadableMixin.ATTR_KEY])
    def from_json(json: dict[str, any]) -> any:
        pass

