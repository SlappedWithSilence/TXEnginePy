import dataclasses

from .structures.messages import Frame
from .structures.state_device import StateDevice

from loguru import logger


@dataclasses.dataclass
class StackState:
    """
    A simple struct to store the properties of the top StateDevice. Only the state of the top device matters--
    extracting these properties and storing them independently of the StateDevice class saves on time and memory.
    """
    dead: bool = False
    error: bool = False
    recoverable: bool | None = None


@dataclasses.dataclass
class GameStateController:
    """
    An object that manages game states.

    GameStateController is singleton class that transforms StateDevices into Frames and delivering user inputs to the
    correct StateDevices.
    """
    state_device_stack: list[StateDevice] = dataclasses.field(default_factory=list)
    state_stack_properties: StackState = StackState()

    # Built-ins

    # Private functions
    def _get_state_device(self, idx: int = -1) -> StateDevice:
        """
        Return the state device at the given index within the stack. By default, this returns the device on the top of
        the stack.

        Args:
            idx: The index of the StateDevice to return. By default, this is '-1' (the top element)

        Returns: The requested StateDevice

        """
        if len(self.state_device_stack) < 1:
            raise ValueError("No StateDevice loaded!")
        return self.state_device_stack[idx]

    def _pop_state_device(self) -> StateDevice:
        """
        Removes the top StateDevice from the state_device_stack and returns it

        Returns: The top StateDevice on the state_device_stack

        """
        logger.info(f"Popping state device: {str(self.state_device_stack[-1])}")
        return self.state_device_stack.pop()

    # Public functions
    def deliver_input(self, user_input: any) -> bool:
        """
        Deliver the user's input to the top StateDevice. Returns True if the device accepts the input.

        Args:
            user_input: Input that the user delivers to the service via the API

        Returns: True if the input is accepted, False otherwise.
        """

        if self._get_state_device().validate_input(user_input):
            self._get_state_device().input(user_input)
            return True

        return False

    def add_state_device(self, device: StateDevice) -> None:
        """
        Appends a StateDevice to the top of the state_device_stack

        Args:
            device: The device to append

        Returns: None

        """
        if type(device) != StateDevice:
            raise TypeError("device must be of type StateDevice!")

        logger.info(f"Adding state device: {str(device)}")
        self.state_device_stack.append(device)

    def set_dead(self, val: bool = True) -> None:
        """
        A public function that allows state devices to mark themselves as terminated at a global scope. This is the
        proper way for a StateDevice to inform the game engine that it should be removed from the stack
        Args:
            val: If the StateDevice is dead, True. Otherwise, False.

        Returns: None
        """
        logger.info(f"Marking {self._get_state_device()} as dead...")
        self.state_stack_properties.dead = val

    def get_current_frame(self) -> Frame:
        """
        Convert the top StateDevice into a Frame and return it.

        Returns: The Frame generated by the top StateDevice in the state_device_stack

        """
        return self._get_state_device().to_frame()
